# 동시성
단일 스레드인 코드는 작성하기 쉽고 겉으로 멀쩡해 보이지만 깊숙한 곳에 문제가 있는 멀티 스레드 코드도 작성하기 쉽다. 이런 코드는 시스템이 부하를 받기 전까지 멀쩡하게 돌아간다. 
동시성이라는 주제로 책한권을 써도 되는 분량일 정도로 어렵고 복잡하다고 한다.
읽어봤지만 어렵다ㅎ

# 동시성이 필요한 이유
동시성은 결합을 없애는 전략이다.
> 무엇과 언제를 분리한다.

특정 시스템은  응답시간과 처리량 개선이라는 요구사항으로 동시성 구현이 불가피하다.
매일 수많은 웹사이트에서 정보를 가져와 요약하는 정보수집기가 있을 때 수집기가 단일 스레드라면
 한 번에 웹사이트를 방문해 정보를 가져오며 이 과정이 끝나야 다음 웹사이트를 방문한다. 다중 스레드를 사용하는 알고리즘을 채택한다면 성능을 개선할 수 있다.

### 미신과 오해
* 동시성은 항상 성능을 높여준다.(x)
  * 대기시간이 길어 여러 스레드가 프로세서를 공유할 수 있는 경우에 성능이 높아짐
  * 여러 프로세스가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아짐
* 동시성을 구현해도 설계는 변하지 않는다.(x)
  * 단일 스레드 시스템과 다중 스레드 시스템은 설계가 다르다!!
  * 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
* 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.(x)
  * 실제로 컨테이너가 어떻게 동작하는지 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야 한다.
* 동시성은 부하를 유발한다.(o)
* 동시성은 복잡하다.(o)
* 동시성 버그는 재현하기 어렵다. 그래서 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다.
* 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

# 난관
```java
public class X{ 
  private int lastIdUsed;
  
  public int getNextId(){
    return ++lastIdUsed;
  }
}
```
위 코드에서 lastIdUsed 필드를 42로 설정한 다음， 두 스레드가 해당 인스턴스를 공유한다.
이때 두 스레드가 변수를 동시에 참조하면 결과는 셋중하나다.
* 한 스레드는 43을 받고 다른 스레드는 44를 받고 lastIdUsed는 44다.
* 한 스레드는 44를 받고 다른 스레드는 43를 받고 lastIdUsed는 44다.
* 한 스레드는 43을 받고 다른 스레드는 43를 받고 lastIdUsed는 43다.

>소신발언 : 마지막 결과는 괴랄한 것 같다.

위 결과에 대해 정확하게 말하려면 JIT 컴파일러가 바이트 코드를 처리하는 방식과 자바 메모리 모델이 원자로 간주하는 최소 단위를 알아야 한다. 간단하게 바이트 코드만 고려했을 때 두 스레드가 getNextId 메서드를 실행하는 잠재적 경로는 12870개에 달한다.
* 대다수는 올바른 결과를 내지만 잘못된 결과를 내놓는 일부가 존재한다는게 문제다.

# 동시성 방어 원칙

### SRP
동시성과 관련된 코드는 다른 코드들과 분리해야 한다. 또한 동시성을 구현할 때 아래 사항들을 고려한다.
* 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
* 동시성 코드에는 독자적인 난관이 있다.
* 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다. 동시성 하나만으로 충분히 어렵다.

>
동시성 코드는 다른 코드와 분리해야한다.

### 따름 정리 : 자료 범위를 제한하라
* 공유 객체를 사용하는 코드 내 임계영역을 synchronized 키워드로 보호하라
* 임계영역의 수를 줄이는게 중요하다.
* 공유자료를 수정하는 위치가 많을 수록 다음 위험도 커진다.
  * 보호할 임계영역을 빼먹는다. 그래서 공유 자료를 수정하는 모든 코드를 망가뜨림
  * 임계영역을 올바르게 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다.
  * 찾기 어려운 버그가 더 찾기 어렵게 된다.

>
자료를 캡슐화 하라. 공유자료를 최대한 줄여라

### 따름 정리 : 자료 사본을 사용하라
* 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 좋다.
* 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.
* 스레드가 객체를 복사하여 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.
* 객체를 복사하는 비용이 synchronized를 없애 절약한 수행 시간을 상쇄시킬 수 있다.

### 따름 정리 : 스레드는 가능한 독립적으로 구현하라
* 다른 스레드와 자료를 공유하지 않는다.
* 각 스레드는 클라이언트 요청 하나를 처리한다.
* 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.

>
독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분리하라.

# 라이브러리를 이해하라
자바 5는 동시성 측면에서 이전 버전보다 많이 나아졌다. 자바 5로 스레드 코드를 구현한다면 다음을 고려하기 바란다.
* 스레드 환경에 안전한 컬렉션을 사용한다.
* 서로 무관한 작업을 수행할 때는 executor 프레임워크를 사용
* 가능하면 스레드가 차단되지 않는 방법 사용하기
* 일부 클래스 라이브러리는 스레드에 안전하지 못하다.

### 스레드 환경에 안전한 컬렉션
* java.util.concurrent 패키지가 제공하는 클래스는 다중 스레드 환경에서 사용해도 안전하며, 성능도 좋다. 
* java.util.concurrent, java.util.concurrent.atomic, java.util.concurrent.lock를 익혀라


# 실행 모델을 이해하라
* 한정된 자원 (Bound Resource)
  * 다중 스레드 환경에서 사용하는 한정된 자원으로 크기나 숫자가 제한적이다.
* 상호 배제 (Mutual Exclusion)
  * 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우
* 기아 (Starvation)
  * 한 스레드나 여러 스레드가 굉장히 오랫동안 또는 영원히 자원을 기다리는 경우
* 데드락 (Deadlock)
  * 여러 스레드가 서로가 끝나기를 기다리는 경우
* 라이브락 (Livelock)
  * 락을 거는 단계에서 각 스레드가 서로를 방해함
  
### 생산자 - 소비자
* 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.(빈공간이 있어야 채움)
* 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.(정보가 있어야 가져옴)
* 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
* 서로에게 시그널을 보내게 되는데, 잘못하면 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 수 있다.

### 읽기 - 쓰기
읽기 스레드를 위한 주된 정보원으로 공유 자원 사용하지만 쓰기 스레드가 이 공유 자원을 갱신한다고 할 때 처리율이 문제의 핵심이다.
* 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다.
* 갱신을 허용하면 처리율에 영향을 미친다.
* 균형잡힌 해법이 필요함

### 식사하는 철학자들
기업 애플리케이션은 여러 프로세스가 자원을 얻으려 경쟁한다. 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하등 여러 문제를 겪는다.

# 동기화 하는 메서드 사이에 존재하는 의존성을 이해하라
동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다.
synchronized를 활용하여 메서드를  보호할 수 있지만 공유 클래스 하나에 동기화 된 메서드가 여럿이라면 구현이 올바른지 확인해야 한다.
> 공유 객체 하나에는 메서드 하나만 사용하라

공유객체 하나에 여러 메서드가 필요한 상황이 발생한다면?
* 클라이언트에서 잠금 - 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다. 마지막메서드를 호출할 때 까지 잠금을 유지한다.
* 서버에서 잠금 - 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현하며 클라이언트는 이 메서드를 호출한다.
* 연결 서버 - 잠금을 수행하는 중간 단계를 생성한다. 원래 서버는 변경하지 않는다.

# 동기화 부분을 작게 만들어라
synchronized는 스레드를 지연시키고 부하를 가중시킨다.
> 동기화하는 부분을 최대한 작게 만들어라

# 올바른 종료 코드는 구현하기 어렵다.
잠시 돌다 깔끔하게 종료하는 코드를 깔끔하게 구현하기는 힘들다.
가장 흔한게 데드락이다. 영원히 오지 않을 시그널을 기다리는 것 이다.
>부모스레드가 자식스레드를 여럿 만든후 자식스레드가 모두 끝나기를 기다리고 자원을 해제하고 종료 해야 하는데 자식스레드가 데드락에 걸린다면 부모 스레드는 영원히 기다리고 시스템도 영원히 돌아간다.

깔끔하게 종료하는 다중 스레드 코드를 짜야 한다면 시간을 투자해 올바르게 구현해야 한다.

> 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라. 생각보다 오래 걸린다. 생각보다 어려우므로 이미 나온 알고리즘을 검토하라.

# 스레드 코드 테스트 하기
코드가 올바르다고 증명하는 것은 현실적으로 불가능하다.
>
문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 테스트가 실패하면 원인을 추적하라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안 된다.

구체적인 지침
* 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
* 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
* 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
* 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
* 프로세서 수보다 많은 스레드를 돌려보라
* 다른 플랫폼에서 돌려보라
* 코드에 보조 코드(instrument)를 넣어 돌려라. 강제로 실패를 일으키게 해보라

### 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라
* 다중 스레드 코드는 말이 안되는 오류를 일으킨다.
* 진짜 수천 수백만번에 한 번씩 드러나기도 해서 실패를 재현하기도 힘들다.
* 일회성 문제로 치부하고 무시하면 잘못된 코드 위에 코드가 계속 쌓인다.
> 시스템 실패를 '일회성'이라 치부하지 마라

### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
>스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라.
먼저 스레드 환경 밖에서 코드를 올바로 돌려라.

### 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
다중 스레드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현하라.
* 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
* 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
* 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
* 반복 테스트가 가능하도록 테스트 케이스를 작성한다.

>다양한 설정에서 실행할 목적으로 다른 환경에 쉽게 끼워 넣을 수 있게 코드를 구현하라.

### 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
* 적절한 스레드 개수를 파악하려면 상당한 시행착오가 필요하다.
* 프로그램이 돌아가는 도중에 스레드 개수를 변경하는 방법도 고려한다.
* 프로그램 처리율과 효율에 따라 스스로 스레드개수를 조율하는 코드도 고민한다.

### 프로세서 수보다 많은 스레드를 돌려보라
* 시스템이 스레드를 스와핑(swapping)할 때도 문제가 발생한다.
* 스와핑을 일으키려면 프로세서 수보다 많은 스레드를 돌린다.
* 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워진다.

### 다른 플랫폼에서 돌려보라
* 다중 스레드 코드는 플랫폼에 따라 다르게 돌아간다. 코드가 돌아갈 가능성이 있는 플랫폼 전부에서 테스트를 수행해야 마땅하다.
> 처음부터 그리고 자주 모든 목표 플랫폼에서 코드를 돌려라.


### 코드에 보조 코드(instrument)를 넣어 돌려라. 강제로 실패를 일으키게 해보라
스레드 버그가 산발적이고 우발적이고 재현이 어려운 이유는 코드가 실행되는 수천 가지 경로 중에 아주 소수만 실패하기 때문이다. 실패하는 경로가 실행될 확률은 극도로 저조하다.


### 직접 구현하여 테스트
* 보조코드를 추가해 코드가 실행되는 순서를 바꿔주어 오류를 좀 더 자주 일으킬수 있도록 할 수 있다.
  * wait,sleep,yield등과 같은 메서드
```java
public synchronized String nextUrlOrNull() {
	if(hasNext()) {
		String url = urlGenerator.next();
		Thread.yield(); // 테스트를 위해 추가
		updateHasNext();
		return url;
	}
	return null;
}
```
yield()를 삽입하면 코드가 실행되는 경로가 바뀐다. 이전에 실패하지 않았던 코드가 실패할 가능성을 열어준다.
코드가 실패한다면 yield()를 추가했기 때문이 아니다. 원래 잘못된 코드인데 증거가 드러났을 뿐이다.

### 자동화
jiggle을 사용해 코드를 흔들고 다른 순서로 실행시키기
ThreadJigglePoing.jiggle() 호출은 무작위로 sleep이나 yield를 호출한다.
>흔들기와 같은 기법을 사용해 오류를 찾아내라
  

